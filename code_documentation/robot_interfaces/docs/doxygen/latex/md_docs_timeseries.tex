In this section the logic of the {\itshape time series} used for communication between front and back end and for synchronization between actions and observations is explained. For more details, please see our \href{https://arxiv.org/abs/2008.03596}{\tt paper} on the open-\/source version of the Tri\+Finger robot.

\subsection*{On Time Series and Time Relation of Actions and Observations }

All data transfer between the front end (= user code) and the back end (= robot hardware) goes through so called time series. When calling {\ttfamily append\+\_\+desired\+\_\+action(action)}, the action is not applied immediately but is {\itshape appended} to the time series of desired actions which serves as a queue.

At each time step, identified by a {\itshape time index t}, the backend takes the action at position {\itshape t} from the \char`\"{}desired actions\char`\"{} time series and sends it to the robot driver. At the same time an observation is acquired from the robot and added to the \char`\"{}observation\char`\"{} time series. This means that the effect of the desired action {\ttfamily a\+\_\+t} is not yet visible in the observation {\ttfamily y\+\_\+t} as is illustrated below. (`a\textquotesingle{}\+\_\+t` corresponds to the {\itshape applied action}, see \hyperlink{md_docs_desired_vs_applied_action}{Desired vs Applied Action})



{\ttfamily append\+\_\+desired\+\_\+action()} returns the time index {\ttfamily t} at which the appended action will be executed. Methods like {\ttfamily get\+\_\+observation()} expect a time index as input. If the specified time step has already passed, they immediately return the value from the corresponding step. If it lies in the future, the method will block and wait until the specified time step is reached and then return.

Note that the buffer size of the time series is limited (see the {\ttfamily history\+\_\+length} argument of {\ttfamily Single\+Process\+Robot\+Data} and {\ttfamily Multi\+Process\+Robot\+Data}). If the buffer is full, the oldest element is discarded. Trying to access an time index that is not in the buffer anymore results in an exception.

This design allows for simple code that is automatically executed at the control rate of the robot\+:


\begin{DoxyCode}
\textcolor{comment}{# send zero-torque action to get first observation, see explanation below}
zero\_torque\_action = robot\_interfaces.trifinger.Action()
t = frontend.append\_desired\_action(zero\_torque\_action)
observation = frontend.get\_observation(t)

\textcolor{keywordflow}{while} \textcolor{keyword}{True}:
    action = smart\_algorithm\_to\_compute\_next\_action(observation)

    t = frontend.append\_desired\_action(action)
    \textcolor{comment}{# The t given above refers to the moment the given action will be}
    \textcolor{comment}{# executed.  Right now, this is in the future, so the following call}
    \textcolor{comment}{# will automatically wait until the action is actually applied to the}
    \textcolor{comment}{# platform}
    observation = frontend.get\_observation(t)
\end{DoxyCode}


\subsubsection*{Send Action to Start Backend}

In the beginning of the program execution, the back end is idle and waiting for the first action. Only after the first action is received, the loop is started that applies actions and writes observations to the time series.

This means {\bfseries you first have to send an action before you can read the first observation!}

There are applications where an observation is needed before sending the first real action (e.\+g. when the action depends on the current position). In this case you need to send a \char`\"{}neutral\char`\"{} action first. How this action may look is robot dependent. The {\itshape Tri\+Finger} robot, for example, can safely be started with a zero-\/torque action\+:

Python\+:


\begin{DoxyCode}
\textcolor{comment}{# an action without arguments defaults to zero torque}
zero\_torque\_action = robot\_interfaces.trifinger.Action()
t = frontend.append\_desired\_action(zero\_torque\_action)
first\_observation = frontend.get\_observation(t)
\end{DoxyCode}


C++\+:


\begin{DoxyCode}
Action zero\_torque\_action = Action::Zero();
\textcolor{keyword}{auto} t = frontend.append\_desired\_action(zero\_torque\_action);
\textcolor{keyword}{auto} first\_observation = frontend.get\_observation(t);
\end{DoxyCode}


Note that the creation of the zero torque action in the above example is specific to the {\itshape Tri\+Finger} robot. For other robots, the creation of the action would need to be adjusted to the action type of that specific robot.

If the back end reaches a time step {\ttfamily t} but the user did not yet provide an action for this time step (e.\+g. because the user code is running slower than 1 k\+Hz), the back end automatically sets the desired action for step {\ttfamily t} to the same as the one of {\ttfamily t -\/ 1}.

This is indicated to the user through the {\ttfamily action\+\_\+repetitions} field in the status message which contains the number of times the current action has been repeated. 