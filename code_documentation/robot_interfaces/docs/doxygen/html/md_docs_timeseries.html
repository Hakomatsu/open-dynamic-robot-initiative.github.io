<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>robot_interfaces: Logic of Actions and Observations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">robot_interfaces
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_docs_timeseries.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Logic of Actions and Observations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this section the logic of the <em>time series</em> used for communication between front and back end and for synchronization between actions and observations is explained. For more details, please see our <a href="https://arxiv.org/abs/2008.03596">paper</a> on the open-source version of the TriFinger robot.</p>
<h2>On Time Series and Time Relation of Actions and Observations </h2>
<p>All data transfer between the front end (= user code) and the back end (= robot hardware) goes through so called time series. When calling <code>append_desired_action(action)</code>, the action is not applied immediately but is <em>appended</em> to the time series of desired actions which serves as a queue.</p>
<p>At each time step, identified by a <em>time index t</em>, the backend takes the action at position <em>t</em> from the "desired actions" time series and sends it to the robot driver. At the same time an observation is acquired from the robot and added to the "observation" time series. This means that the effect of the desired action <code>a_t</code> is not yet visible in the observation <code>y_t</code> as is illustrated below. (`a'_t` corresponds to the <em>applied action</em>, see <a class="el" href="md_docs_desired_vs_applied_action.html">Desired vs Applied Action</a>)</p>
<div class="image">
<img src="action_observation_timing.png" alt="action_observation_timing.png"/>
<div class="caption">
Time relation of actions and observations</div></div>
<p><code>append_desired_action()</code> returns the time index <code>t</code> at which the appended action will be executed. Methods like <code>get_observation()</code> expect a time index as input. If the specified time step has already passed, they immediately return the value from the corresponding step. If it lies in the future, the method will block and wait until the specified time step is reached and then return.</p>
<p>Note that the buffer size of the time series is limited (see the <code>history_length</code> argument of <code>SingleProcessRobotData</code> and <code>MultiProcessRobotData</code>). If the buffer is full, the oldest element is discarded. Trying to access an time index that is not in the buffer anymore results in an exception.</p>
<p>This design allows for simple code that is automatically executed at the control rate of the robot:</p>
<div class="fragment"><div class="line"><span class="comment"># send zero-torque action to get first observation, see explanation below</span></div><div class="line">zero_torque_action = robot_interfaces.trifinger.Action()</div><div class="line">t = frontend.append_desired_action(zero_torque_action)</div><div class="line">observation = frontend.get_observation(t)</div><div class="line"></div><div class="line"><span class="keywordflow">while</span> <span class="keyword">True</span>:</div><div class="line">    action = smart_algorithm_to_compute_next_action(observation)</div><div class="line"></div><div class="line">    t = frontend.append_desired_action(action)</div><div class="line">    <span class="comment"># The t given above refers to the moment the given action will be</span></div><div class="line">    <span class="comment"># executed.  Right now, this is in the future, so the following call</span></div><div class="line">    <span class="comment"># will automatically wait until the action is actually applied to the</span></div><div class="line">    <span class="comment"># platform</span></div><div class="line">    observation = frontend.get_observation(t)</div></div><!-- fragment --><h3>Send Action to Start Backend</h3>
<p>In the beginning of the program execution, the back end is idle and waiting for the first action. Only after the first action is received, the loop is started that applies actions and writes observations to the time series.</p>
<p>This means <b>you first have to send an action before you can read the first observation!</b></p>
<p>There are applications where an observation is needed before sending the first real action (e.g. when the action depends on the current position). In this case you need to send a "neutral" action first. How this action may look is robot dependent. The <em>TriFinger</em> robot, for example, can safely be started with a zero-torque action:</p>
<p>Python:</p>
<div class="fragment"><div class="line"><span class="comment"># an action without arguments defaults to zero torque</span></div><div class="line">zero_torque_action = robot_interfaces.trifinger.Action()</div><div class="line">t = frontend.append_desired_action(zero_torque_action)</div><div class="line">first_observation = frontend.get_observation(t)</div></div><!-- fragment --><p>C++:</p>
<div class="fragment"><div class="line">Action zero_torque_action = Action::Zero();</div><div class="line"><span class="keyword">auto</span> t = frontend.append_desired_action(zero_torque_action);</div><div class="line"><span class="keyword">auto</span> first_observation = frontend.get_observation(t);</div></div><!-- fragment --><p>Note that the creation of the zero torque action in the above example is specific to the <em>TriFinger</em> robot. For other robots, the creation of the action would need to be adjusted to the action type of that specific robot.</p>
<p>If the back end reaches a time step <code>t</code> but the user did not yet provide an action for this time step (e.g. because the user code is running slower than 1 kHz), the back end automatically sets the desired action for step <code>t</code> to the same as the one of <code>t - 1</code>.</p>
<p>This is indicated to the user through the <code>action_repetitions</code> field in the status message which contains the number of times the current action has been repeated. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
